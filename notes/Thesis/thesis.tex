\documentclass[a4paper, 12pt, twoside]{report}
\usepackage[english]{babel}
\usepackage[top=4cm,bottom=4cm,left=3cm,right=3cm,asymmetric]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb, amsfonts, amsthm, dsfont}
\usepackage{relsize}
\usepackage{tikz}
\usetikzlibrary{arrows.meta, calc, positioning}
\usepackage{float}
\usepackage{caption}
\usepackage{fancyhdr}
\usepackage{bibgerm} 
\usepackage{cite}
\usepackage[hidelinks]{hyperref}
\usepackage[all]{hypcap}
\usepackage{subcaption} 
\usepackage{setspace}
\usepackage{mdframed}
\captionsetup[figure]{labelfont=it, font=footnotesize}
\captionsetup[subfigure]{labelfont=it,font=footnotesize}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}

\newcommand*\ruleline[1]{\par\noindent\raisebox{.8ex}{\makebox[\linewidth]{\hrulefill\hspace{1ex}\raisebox{-.8ex}{#1}\hspace{1ex}\hrulefill}}}


\parindent0em

\begin{document}
	
	\begin{titlepage}
		\centering
		{\large \scshape Rheinisch-Westfälische Technische Hochschule Aachen}\\
		{\large
			Chair for Software Modeling and Verification\\
			Prof. Dr. Ir. Dr. h. c. Joost-Pieter Katoen\\}
		\vspace*{\fill}
		{\large \ruleline{Master Thesis}}\\
		\vspace{1cm}
		\textbf{\Huge Comparing Hierarchical and On-The-Fly Model Checking for Java Pointer Programs}\\
		\vspace{1cm}
		\hrule
		\vspace{1cm}
		{\Large \textbf{Sally Chau} \\}
		\vspace{0.25cm}
		{\large Matriculation Number 370584} \\
		%\vspace{0.3cm}
		{\large \today}\\
		\vspace{3cm}
		{\large First Reviewer: apl. Prof. Dr. Thomas Noll \\ Second Reviewer: Prof. Dr. Ir. Dr. h. c. Joost-Pieter Katoen \\ Supervisor: Christoph Matheja} \\ 
		\vspace{1cm}
		\vspace*{\fill}
	\end{titlepage}
	
	\pagestyle{empty}
	
	\clearpage\mbox{}\clearpage
	
	\chapter*{Acknowledgement} 
	
	
	\clearpage\mbox{}\clearpage
	
	\chapter*{Eidesstattliche Erklärung}
	
	Hiermit versichere ich an Eides statt und durch meine Unterschrift, dass die vorliegende Arbeit von mir selbstständig, ohne fremde Hilfe angefertigt worden ist. Inhalte und Passagen, die aus fremden Quellen stammen und direkt oder indirekt übernommen worden sind, wurden als solche kenntlich gemacht. Ferner versichere ich, dass ich keine andere, außer der im Literaturverzeichnis angegebenen Literatur verwendet habe. Die Arbeit wurde bisher keiner Prüfungsbehörde vorgelegt und auch noch nicht veröffentlicht.
	\vspace{20 mm}
	
	\noindent\line(1,0){250}\\
	Bonn, den 28. September 2015, Sally Chau
	
	\clearpage\mbox{}\clearpage
	
	\chapter*{Abstract}
	
	\clearpage\mbox{}\clearpage
	
	\doublespacing
	\tableofcontents
	\singlespacing
	\clearpage\mbox{}\clearpage
	\thispagestyle{empty} 
	
	\pagestyle{fancy}
	\fancyhead[RE]{\nouppercase\leftmark}
	\fancyhead[LO]{\nouppercase\rightmark}
	\fancyhead[LE,RO]{\thepage}
	\cfoot{}
	
	
	\chapter{Introduction}
	
	\section{Attestor}
	% include current model checking approach (only checking main state space)
	
	\section{Related Work}
	
	\chapter{Preliminaries}
	
	\section{Notation}
	
	\section{(Abstract) Heap Representation}
	% how to represent single states
	\subsection{Heap Representation}
	\subsection{Hyperedge Replacement Grammars}
	
	% how to represent paths
	\subsection{Transition Systems}
	
	\begin{definition}[Transition System \cite{baier2008principles}]\label{def:transition system}
		Inhalt...
	\end{definition}

	\begin{definition}[Paths \cite{baier2008principles}]\label{def:paths}
		Inhalt...
	\end{definition}
	
	
	\section{Model Checking}
	% Introduction: what is model checking? want to verify path properties for state spaces generated by attestor
	% define transition system, paths, property, state, satisfies
	% model relation
	
	\subsection{Linear Temporal Logic}
	%
	
	% reference book "Principles of Model Checking"
	 
	First proposed by Pnueli in 1977, \textit{Linear Temporal Logic} (LTL) is a model temporal logic that is used to describe properties of paths in transition systems. LTL formulae are built up from three components: the boolean operators \textit{negation} ($\neg$) and \textit{conjunction} ($\wedge$), the temporal operators \textit{next} ($\bigcirc$) and \textit{until} ($\textbf{\textup{U}}$), and a set of atomic propositions $AP$. Atomic propositions are state labels of a transition system, which express properties for a single state, e.g., "$i=1$". Formally, the set of LTL formulae is defined as follows:
	
	\begin{definition}[Syntax of LTL \cite{baier2008principles}]\label{def:ltl_syntax}
		Given a set $AP$ of atomic propositions with $a \in AP$, \textup{LTL formulae} are recursively defined by
		\begin{equation*}		
			\varphi := \texttt{\textup{true}} \mid a \mid \neg \varphi \mid \varphi_1 \wedge \varphi_2 \mid \bigcirc \varphi \mid \varphi_1 \textbf{\textup{U}} \varphi_2.
		\end{equation*}
	\end{definition}

	% describe every formula type and when they are fulfilled by a path -> model relation
	% include graphics for each formula
	Further temporal operators that are commonly used, but are not included in the definition of LTL formulae, are the temporal modalities \textit{eventually}  ($\lozenge$), \textit{globally} ($\square$), and \textit{release} ($\textbf{\textup{R}}$). They can be derived using the operators given in Definition~\ref{def:ltl_syntax} as follows: 
	
	\begin{align*}		
		\lozenge \varphi &:= \texttt{\textup{true}} \textbf{\textup{U}} \varphi\\
		\square \varphi &:= \neg \lozenge\neg\varphi\\
		\varphi_1 \textbf{\textup{R}} \varphi_2 &:= \neg(\neg\varphi_1 \textbf{\textup{U}} \neg \varphi_2).
	\end{align*}
	
	In order to get an intuitive understanding of the semantics of temporal operators, and therefore LTL formulae, we visualize the semantics of temporal operators in Figure~\ref{fig:temporal_ops}.
	
	\begin{figure}[h!]
		\begin{center}		
			\begin{tikzpicture}
				[node distance=2cm,thick,
				normal/.style={circle, draw, fill=white, thick, font=\sffamily\Large\bfseries}]
				
				\node (1) at (2,0) [normal, label=90:$1$, label=-90:$\texttt{\textup{true}}$] {};
				\node (2) at (3.5,0) [normal, label=90:$2$, label=-90:$\texttt{\textup{true}}$] {};
				\node (3) at (5,0) [normal, label=90:$i$, label=-90:$\texttt{\textup{true}}$] {};
				\node (4) at (6.5,0) [normal, label=90:$i+1$, label=-90:$\texttt{\textup{true}}$] {};
				\node (5) at (8,0) {};
				\draw[->,shorten >=0.5pt,out=0,in=180] (1) to (2);	
				\draw[->,shorten >=0.5pt,out=0,in=180,dashed] (2) to (3);	
				\draw[->,shorten >=0.5pt,out=0,in=180] (3) to (4);
				\draw[->,shorten >=0.5pt,out=0,in=180,dashed] (4) to (5);	
				
				\node () at (0,0) {$\texttt{\textup{true}}$};
				\node () at (11.5,0) [align=left,text width=6cm]{$\texttt{\textup{true}}$ is fullfilled by every state, thus $\varphi=\texttt{\textup{true}}$ if fullfilled by every path $\pi$.};	
				
				\node (1) at (2,-2) [normal, label=90:$1$, label=-90:$\models a$] {};
				\node (2) at (3.5,-2) [normal, label=90:$2$] {};
				\node (3) at (5,-2) [normal, label=90:$3$] {};
				\node (4) at (6.5,-2) [normal, label=90:$4$] {};
				\node (5) at (8,-2) {};
				\draw[->,shorten >=0.5pt,out=0,in=180] (1) to (2);	
				\draw[->,shorten >=0.5pt,out=0,in=180] (2) to (3);
				\draw[->,shorten >=0.5pt,out=0,in=180] (3) to (4);	
				\draw[->,shorten >=0.5pt,out=0,in=180,dashed] (4) to (5);	
				
				\node () at (0,-2) {$a$};
				\node () at (11.5,-2) [align=left,text width=6cm]{...};	
				
				\node (1) at (2,-4) [normal, label=90:$1$, label=-90:$\neg\varphi$] {};
				\node (2) at (3.5,-4) [normal, label=90:$2$] {};
				\node (3) at (5,-4) [normal, label=90:$3$] {};
				\node (4) at (6.5,-4) [normal, label=90:$4$] {};
				\node (5) at (8,-4) {};
				\draw[->,shorten >=0.5pt,out=0,in=180] (1) to (2);	
				\draw[->,shorten >=0.5pt,out=0,in=180] (2) to (3);
				\draw[->,shorten >=0.5pt,out=0,in=180] (3) to (4);	
				\draw[->,shorten >=0.5pt,out=0,in=180,dashed] (4) to (5);		
				
				\node () at (0,-4) {$\neg\varphi$};
				\node () at (11.5,-4) [align=left,text width=6cm]{...};
				
				\node (1) at (2,-6) [normal, label=90:$1$, label=-90:$\varphi_1 \wedge \varphi_2$] {};
				\node (2) at (3.5,-6) [normal, label=90:$2$] {};
				\node (3) at (5,-6) [normal, label=90:$3$] {};
				\node (4) at (6.5,-6) [normal, label=90:$4$] {};
				\node (5) at (8,-6) {};
				\draw[->,shorten >=0.5pt,out=0,in=180] (1) to (2);	
				\draw[->,shorten >=0.5pt,out=0,in=180] (2) to (3);
				\draw[->,shorten >=0.5pt,out=0,in=180] (3) to (4);	
				\draw[->,shorten >=0.5pt,out=0,in=180,dashed] (4) to (5);	
				
				\node () at (0,-6) {$\varphi_1 \wedge \varphi_2$};
				\node () at (11.5,-6) [align=left,text width=6cm]{...};	
				
				\node (1) at (2,-8) [normal, label=90:$1$] {};
				\node (2) at (3.5,-8) [normal, label=90:$2$, label=-90:$\varphi$] {};
				\node (3) at (5,-8) [normal, label=90:$3$] {};
				\node (4) at (6.5,-8) [normal, label=90:$4$] {};
				\node (5) at (8,-8) {};
				\draw[->,shorten >=0.5pt,out=0,in=180] (1) to (2);	
				\draw[->,shorten >=0.5pt,out=0,in=180] (2) to (3);
				\draw[->,shorten >=0.5pt,out=0,in=180] (3) to (4);	
				\draw[->,shorten >=0.5pt,out=0,in=180,dashed] (4) to (5);		
				
				\node () at (0,-8) {$\bigcirc \varphi$};
				\node () at (11.5,-8) [align=left,text width=6cm]{...};		
				
				\node (1) at (2,-10) [normal, label=90:$1$, label=-90:$\varphi_1$] {};
				\node (2) at (3.5,-10) [normal, label=90:$i-1$,label=-90:$\varphi_1$] {};
				\node (3) at (5,-10) [normal, label=90:$i$,label=-90:$\varphi_2$] {};
				\node (4) at (6.5,-10) [normal, label=90:$i+1$] {};
				\node (5) at (8,-10) {};
				\draw[->,shorten >=0.5pt,out=0,in=180,dashed] (1) to (2);	
				\draw[->,shorten >=0.5pt,out=0,in=180] (2) to (3);	
				\draw[->,shorten >=0.5pt,out=0,in=180] (3) to (4);
				\draw[->,shorten >=0.5pt,out=0,in=180,dashed] (4) to (5);		
				
				\node () at (0,-10) {$\varphi_1 \textbf{\textup{U}} \varphi_2$};
				\node () at (11.5,-10) [align=left,text width=6cm]{...};
				
				\node (1) at (2,-12) [normal, label=90:$1$] {};
				\node (2) at (3.5,-12) [normal, label=90:$i-1$] {};
				\node (3) at (5,-12) [normal, label=90:$i$,label=-90:$\varphi$] {};
				\node (4) at (6.5,-12) [normal, label=90:$i+1$] {};
				\node (5) at (8,-12) {};
				\draw[->,shorten >=0.5pt,out=0,in=180,dashed] (1) to (2);	
				\draw[->,shorten >=0.5pt,out=0,in=180] (2) to (3);	
				\draw[->,shorten >=0.5pt,out=0,in=180] (3) to (4);
				\draw[->,shorten >=0.5pt,out=0,in=180,dashed] (4) to (5);
				
				\node () at (0,-12) {$\lozenge\varphi$};
				\node () at (11.5,-12) [align=left,text width=6cm]{...};
				
				\node (1) at (2,-14) [normal, label=90:$1$,label=-90:$\varphi$] {};
				\node (2) at (3.5,-14) [normal, label=90:$2$,label=-90:$\varphi$] {};
				\node (3) at (5,-14) [normal, label=90:$3$,label=-90:$\varphi$] {};
				\node (4) at (6.5,-14) [normal, label=90:$4$,label=-90:$\varphi$] {};
				\node (5) at (8,-14) {};
				\draw[->,shorten >=0.5pt,out=0,in=180] (1) to (2);	
				\draw[->,shorten >=0.5pt,out=0,in=180] (2) to (3);
				\draw[->,shorten >=0.5pt,out=0,in=180] (3) to (4);	
				\draw[->,shorten >=0.5pt,out=0,in=180,dashed] (4) to (5);	
				
				\node () at (0,-14) {$\square \varphi$};
				\node () at (11.5,-14) [align=left,text width=6cm]{...};
				
				\node (1) at (2,-16) [normal, label=90:$1$, label=-90:$\varphi_2$] {};
				\node (2) at (3.5,-16) [normal, label=90:$i-1$,label=-90:{$\varphi_2,\varphi_1$}] {};
				\node (3) at (5,-16) [normal, label=90:$i$,label=-90:$\varphi_1$] {};
				\node (4) at (6.5,-16) [normal, label=90:$i+1$,label=-90:$\varphi_1$] {};
				\node (5) at (8,-16) {};
				\draw[->,shorten >=0.5pt,out=0,in=180,dashed] (1) to (2);	
				\draw[->,shorten >=0.5pt,out=0,in=180] (2) to (3);	
				\draw[->,shorten >=0.5pt,out=0,in=180] (3) to (4);
				\draw[->,shorten >=0.5pt,out=0,in=180,dashed] (4) to (5);
				
				\node () at (0,-16) {$\varphi_1 \textbf{\textup{R}} \varphi_2$};
				\node () at (11.5,-16) [align=left,text width=6cm]{...};
				
				\node (1) at (2,-18) [normal, label=90:$1$, label=-90:$\varphi_2$] {};
				\node (2) at (3.5,-18) [normal, label=90:$2$,label=-90:$\varphi_2$] {};
				\node (3) at (5,-18) [normal, label=90:$3$,label=-90:$\varphi_2$] {};
				\node (4) at (6.5,-18) [normal, label=90:$4$,label=-90:$\varphi_2$] {};
				\node (5) at (8,-18) {};
				\draw[->,shorten >=0.5pt,out=0,in=180] (1) to (2);	
				\draw[->,shorten >=0.5pt,out=0,in=180] (2) to (3);
				\draw[->,shorten >=0.5pt,out=0,in=180] (3) to (4);	
				\draw[->,shorten >=0.5pt,out=0,in=180,dashed] (4) to (5);
				
				\node () at (0,-18) {$\varphi_1 \textbf{\textup{R}} \varphi_2$};
				\node () at (11.5,-18) [align=left,text width=6cm]{...};
		\end{tikzpicture}
		\caption{Intuitive semantics of temporal operators.}\label{fig:temporal_ops}
		\end{center}
	\end{figure}

	\begin{definition}[Semantics of LTL \cite{baier2008principles}]\label{def:ltl_semantics}
		Given an LTL formula $\varphi$, a concrete transition system $S$, and a path $\pi \in Path_S$, the model relation $\models$ for LTL formulae is defined by the model relation
		\begin{align*}
			\pi &\models \texttt{\textup{true}}   \\
			\pi &\models a &&\Leftrightarrow \pi[1] \models a\\			
			\pi &\models \neg \varphi &&\Leftrightarrow \textup{ not } \pi[1] \models \varphi\\
			\pi &\models \varphi_1 \wedge \varphi_2 &&\Leftrightarrow (\pi \models \varphi_1) \textup{ and } (\pi \models \varphi_2)\\
			\pi &\models \bigcirc \varphi &&\Leftrightarrow \pi[2...] \models \varphi\\
			\pi &\models \varphi_1 \textbf{\textup{U}} \varphi_2 &&\Leftrightarrow \exists i \geq 1.(\pi[i...] \models \varphi_2 \wedge (\forall 1\leq k < i. \pi[k...] \models \varphi_1))\\
			\pi &\models \lozenge \varphi &&\Leftrightarrow \exists i \geq 1.\pi[i...] \models \varphi\\
			\pi &\models \square \varphi &&\Leftrightarrow \forall i \geq 1. \pi[i...] \models \varphi\\
			\pi &\models \varphi_1 \textbf{\textup{R}} \varphi_2  &&\Leftrightarrow \forall i \geq 1.\pi[i...]\models \varphi_2 \textup{ or } \exists i \geq 1.(\pi[i...] \models \varphi_1 \wedge (\forall 1\leq k < i. \pi[k...] \models \varphi_2)).
		\end{align*}
		%TODO move F,G,R outside of def
		Given a state $s\in S_S$, $s \models \varphi$ if for all $\pi \in Path_S$ it holds that $\pi \models \varphi$. For a transition system $S$, $S \models \varphi$ if for all $\pi \in Paths_S$ it holds that $\pi \models \varphi$. %TODO adjust abreveations
	\end{definition}

	%explanation of PNF
% every LTL formula can be expressed as PNF
	
	\begin{definition}[Positive Normal Form \cite{baier2008principles}]\label{def:ltl_pnf}
		Given a set $AP$ of atomic propositions with $a \in AP$, LTL formulae in \textup{positive normal form} (PNF) are defined by
		\begin{equation*}		
		\varphi := \texttt{\textup{true}} \mid \texttt{\textup{false}} \mid a \mid \neg a \mid \varphi_1 \wedge \varphi_2 \mid \varphi_1 \vee \varphi_2 \mid \bigcirc \varphi \mid \varphi_1 \textbf{\textup{U}} \varphi_2 \mid \varphi_1 \textbf{\textup{R}} \varphi_2.
		\end{equation*}
	\end{definition}


	
	%example for LTL
	
	\subsection{LTL Model Checking}
	%Tableau method
	
	\section{Recursive State Machines} 
	% reference paper "Analysis of Recursive States Machines"
		\begin{definition}[Recursive State Machine \cite{alur2001analysis}]\label{def:rsm}
			A \textup{recursive state machine} (RSM) $A$ over a finite alphabet $\Sigma$ is given by a tuple $(A_1, ..., A_k)$, where each \textup{component state machine} (CSM) $A_i = (N_i \cup B_i, Y_i, En_i, Ex_i, \delta_i)$, $1 \leq i \leq k$, consists of
			\begin{itemize}
				\item a set $N_i$ of \textup{nodes} and a (disjoint) set $B_i$ of \textup{boxes},
				\item a \textup{labeling} $Y_i: B_i \mapsto \{1, ..., k\}$ that assigns to every box an index $j \in \{1, ..., k\}$ referring to one of the component state machines $A_1, ..., A_k$,
				\item a set of \textup{entry nodes} $En_i \subseteq N_i$,
				\item a set of \textup{exit nodes} $Ex_i \subseteq N_i$, and
				\item a \textup{transition relatio}n $\delta_i$, where transitions are of the form $(u, \sigma, v)$, where 
				\begin{itemize}
					\item the source $u$ is either a node of $N_i$ or a pair $(b, x)$, where $b$ is a box in $B_i$ and $x$ is an exit node in $Ex_j$ for $j = Y_i(b)$,
					\item the label $\sigma$ is in $\Sigma$, and 
					\item the destination $v$ is either a node in $N_i$ or a pair $(b, e)$, where $b$ is a box in $B_i$ and $e$ is an entry node in $En_j$ for $j = Y_i(b)$.
				\end{itemize}
			\end{itemize}
		\end{definition}
	
	%some explanations
	
	% example RSM
	\begin{figure}[!h]
		\begin{center}
			%\resizebox{0.7\textwidth}{!}{
				\begin{tikzpicture}
			%	\draw [gray, line width=0.05pt] (0.1,0.1) rectangle (0.2,0.2);
				[node distance=2cm,thick,
				normal/.style={circle, draw, fill=white, thick, font=\sffamily\Large\bfseries},
				rectstyle/.style={draw, minimum width=7.5cm, minimum height=4.5cm, rounded corners=1.5pt, fill=gray!5}]
		
				\node (a1) at (-3.5, 2.5) {$A_1$};
				\node (rect1) at (0,0) [rectstyle] {};
				\node (u1) at (-3.75,1) [normal, label=180:$u_1$] {};
				\node (u2) at (-3.75,-1) [normal, label=180:$u_2$] {};
				\node (u3) at (-2,-1) [normal, label=-90:$u_3$] {};
				\node (u4) at (3.75, 0) [normal, label=0:$u_4$] {};
				%boxes
				\node (b1) at (0,1) [draw,thick,minimum width=2.5cm,minimum height=1.5cm,fill=gray!20,rounded corners=1.5pt] {$b_1:A_2$};
				\node (b11) at (-1.25,0.75) [normal, minimum size=0.2cm, inner sep=0pt] {};
				\node (b12) at (-1.25,1.25) [normal, minimum size=0.2cm, inner sep=0pt] {};
				\node (b13) at (1.25,0.75) [normal, minimum size=0.2cm, inner sep=0pt] {};
				\node (b14) at (1.25,1.25) [normal, minimum size=0.2cm, inner sep=0pt] {};
				\node (b2) at (1,-1) [draw,thick,minimum width=2.5cm,minimum height=1.5cm,fill=gray!20,rounded corners=1.5pt] {$b_2:A_3$};
				\node (b21) at (-0.25,-1) [normal, minimum size=0.2cm, inner sep=0pt] {};
				\node (b22) at (2.25,-1) [normal, minimum size=0.2cm, inner sep=0pt] {};
				% arrows
				\draw[->,shorten >=0.5pt,out=0,in=180] (u1) to (b12);
				\draw[->,shorten >=0.5pt,out=0,in=180] (u2) to (u3);
				\draw[->,shorten >=0.5pt,out=0,in=180] (u3) to (b21);
				\draw[->,shorten >=0.5pt,out=0,in=225] (b22) to (u4);
				\draw[->,shorten >=0.5pt,out=0,in=135] (b14) to (u4);
				\draw[->,shorten >=0.5pt,out=-45,in=225,distance=1.5cm] (b13) to (b11);
				
				\node (a2) at (-3.5, -3) {$A_2$};
				\node (rect2) at (0,-5.5) [rectstyle] {};
				\node (v1) at (-3.75,-4.5) [normal, label=180:$v_1$] {};
				\node (v2) at (-3.75,-6.5) [normal, label=180:$v_2$] {};
				\node (v3) at (3.75, -4.5) [normal, label=0:$v_3$] {};
				\node (v4) at (3.75,-6.5) [normal, label=0:$v_4$] {};
				%boxes
				\node (c1) at (0,-4.5) [draw,thick,minimum width=2.5cm,minimum height=1.5cm,fill=gray!20,rounded corners=1.5pt] {$c_1:A_2$};
				\node (c11) at (-1.25,-4.25) [normal, minimum size=0.2cm, inner sep=0pt] {};
				\node (c12) at (-1.25,-4.75) [normal, minimum size=0.2cm, inner sep=0pt] {};
				\node (c13) at (1.25,-4.25) [normal, minimum size=0.2cm, inner sep=0pt] {};
				\node (c14) at (1.25,-4.75) [normal, minimum size=0.2cm, inner sep=0pt] {};
				\node (c2) at (0,-6.5) [draw,thick,minimum width=2.5cm,minimum height=1.5cm,fill=gray!20,rounded corners=1.5pt] {$c_2:A_3$};
				\node (c21) at (-1.25,-6.5) [normal, minimum size=0.2cm, inner sep=0pt] {};
				\node (c22) at (1.25,-6.5) [normal, minimum size=0.2cm, inner sep=0pt] {};
				% arrows
				\draw[->,shorten >=0.5pt,out=0,in=180] (v1) to (c11);
				\draw[->,shorten >=0.5pt,out=45,in=180] (v2) to (c12);
				\draw[->,shorten >=0.5pt,out=-45,in=180] (v2) to (c21);
				\draw[->,shorten >=0.5pt,out=45,in=225,distance=2.75cm] (c22) to (c12);
				\draw[->,shorten >=0.5pt,out=0,in=-135] (c22) to (v4);
				\draw[->,shorten >=0.5pt,out=0,in=135] (c13) to (v4);
				\draw[->,shorten >=0.5pt,out=0,in=180] (c14) to (v3);
				
				\node (a3) at (-3.5, -8.5) {$A_3$};
				\node (rect3) at (0,-11) [rectstyle] {};
				\node (w1) at (-3.75,-11) [draw, thick, fill=white, circle, label=180:$w_1$] {};
				\node (w2) at (3.75,-11) [draw, thick, fill=white, circle, label=0:$w_2$] {};
				%boxes
				\node (d) at (0,-11) [draw, thick, fill=gray!20,minimum width=2.5cm,minimum height=1.5cm,rounded corners=1.5pt] {$d:A_1$};
				\node (d1) at (-1.25,-10.75) [draw, thick, fill=white, circle, minimum size=0.2cm, inner sep=0pt] {};
				\node (d2) at (-1.25,-11.25) [draw, thick, fill=white, circle, minimum size=0.2cm, inner sep=0pt] {};
				\node (d3) at (1.25,-11) [draw, thick, fill=white, circle, minimum size=0.2cm, inner sep=0pt] {};
				% arrows
				\draw[->,shorten >=0.5pt,out=0,in=180] (w1) to (d1);
				\draw[->,shorten >=0.5pt,out=0,in=135] (d3) to (w2);
				\draw[->,shorten >=0.5pt,out=-45,in=-135] (w1) to (w2);
				
				\end{tikzpicture}%}
			\caption{A sample recursive state machine. Adopted from \cite{alur2001analysis}. Describe more....}\label{fig:rsm}
		\end{center}
	\end{figure}
	
	\subsection{Semantics}
	% semantics of RSM
	In order to define the execution of an RSM $A=(A_1, ..., A_k)$, this section describes the global relation between its component state machines $A_i, 1 \leq i \leq k$. A \textit{global state} of an RSM consists of boxes and nodes of its CSMs.
	
	\begin{definition}[(Global) State \cite{alur2001analysis}]\label{def:rsm_semantics}
		A \textup{(global) state} of an RSM $A=(A_1, ..., A_k)$ is a tuple $(b_1, ..., b_r, u)$, where $b_1, ..., b_r$ are boxes and $u$ is a node. The set $Q$ of global states of $A$ is $B^*N$, where $B=\bigcup_iB_i$ and $N=\bigcup_iN_i$. A state $(b_1, ..., b_r, u)$ with $b_i \in {B_j}_i$ for $1 \leq i \leq r$ and $u \in N_j$ is \textup{well-formed} if ${Y_j}_i(b_i) = j_{i+1}$ for $1 \leq i < r$ and ${Y_j}_r(b_r) = j$.
	\end{definition}

	%A state $(b_1, ..., b_r, u)$ of an RSM $A=(A_1, ..., A_k)$ can also be viewed as a string. 
	% example here
	
	A well-formed state $(b_1, ..., b_r, u)$ of an RSM $A=(A_1, ..., A_k)$ corresponds to a path through the components $A_j$ of $A$, where we enter component $A_j$ via box $b_r$ of component ${A_j}_r$.
	
	% example
	
	In order to transition between global states of an RSM $A$, we require the notion of a \textit{global transition relation} $\delta$ which enables us to not only transition between states within a CSM $A_j$ as defined by its transition relation $\delta_j$, but also between pairs of CSMs.
	
	\begin{definition}[(Global) Transition Relation \cite{alur2001analysis}]\label{def:rsm_transitionRelation}
		Let $s=(b_1, ..., b_r, u) \in Q$ be a state with $u\in N_j$ and $b_r \in B_m$ for an RSM $A=(A_1, ..., A_k)$. A \textup{(global) transition relation} $\delta$ for $A$ defines $(s, \sigma, s') \in \delta$ if and only if one of the following holds:
		\begin{enumerate}
			\item $(u, \sigma, u') \in \delta_j$ for a node $u'$ of $A_j$ and $s'=(b_1, ..., b_r, u')$.
			\item $(u, \sigma, (b',e))\in \delta_j$ for a box $b'$ of $A_j$ and $s'=(b_1, ..., b_r, b', e)$.
			\item $u$ is an exit-node of $A_j$, $((b_r, u), \sigma, u') \in \delta_m$ for a node $u'$ of $A_m$, and $s'=(b_1, ..., b_{r-1}, u')$.
			\item $u$ is an exit-node of $A_j$, $((b_r, u), \sigma, (b',e)) \in \delta_m$ for a box $b'$ of $A_m$, and $s'=(b_1, ..., b_{r-1}, b', e)$.
		\end{enumerate}
	\end{definition}

	Definition~\ref{def:rsm_transitionRelation} defines the possible kinds of transitions between global states $s, s' \in Q$ of an RSM $A$. Case 1 describes the scenario where the source and the destination states are both within the same component $A_j$, while case 2 depicts that a new component is entered via a box $b'$ of $A_j$. Thus, the current node of the destination state $s'$ is the entry-node $e$. Case 3 and 4 are both exiting component $A_j$ via the exit-node $u$. While case 3 returns to component $A_m$, from where we entered $A_j$ before, case 4 directly enters a new component via box $b'$ of component $A_m$.
	
	% depict cases graphically here
	
	After defining the terms of global states and the global transition relation for an RSM $A$, we can summarize these components together with the finite alphabet $\Sigma$ within the concept of a \textit{labeled transition system} $T_A$, which encodes the execution of $A$.
	
	\begin{definition}[Labeled Transition System \cite{alur2001analysis}]\label{def:rsm_transitionSystem}
		For an RSM $A=(A_1, ..., A_k)$, the \textup{labeled transition system} (LTS) $T_A=(Q, \Sigma, \delta)$ consists of
		\begin{itemize}
			\item a set of global states $Q$, 
			\item a finite alphabet $\Sigma$, and
			\item a global transition relation $\delta$.
		\end{itemize}		
		The LTS of an RSM $A$ is also called the \textup{unfolding} of $A$.
	\end{definition}
	
	\chapter{Hierarchical Model Checking with Recursive State Machines}	
	% briefly describe Büchi automaton and why it is not practical
	\section{Algorithm}
	\section{Implementation}
	\section{Evaluation}
	
	
	\chapter{On-The-Fly Hierarchical Model Checking}
	\section{Algorithm}
	\section{Implementation}
	\section{Evaluation}
	
	\chapter{Benchmarks}	
	\section{Experimental Setup}
	Describe Technical details here
	\section{Instances}
	Describe code examples and properties here
	\section{Result}
	Table of values
	
	\chapter{Conclusion}
	\section{Discussion}	
	\section{Outlook}
	
		- hierarchical failure trace and counter example generation, spuriosity
	- hybrid method between on-the-fly and RSM
	
	\bibliographystyle{gerplain}
	\bibliography{lit}{}
	
\end{document}